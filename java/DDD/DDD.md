DDD start 세미나 내용 정리

# Bounded Context + Microservice

기존 단일 시스템의 성장: 단일 코드에 통합 DB의 형태로.
    서비스가 계속되면서 코드 베이스가 커지는 형태
    단일 코드를 여러 팀에서 작업

    각 레이어의 상호 의존도가 높아지면서 거대한 강결합
    도메인 측면에서 문제 : 수직적으로 언어(도메인?) 경계가 없어짐, 통합 DB에서도 언어의 경계가 없어짐.
    컨텍스트 안에서만 존재하는 의미가 사라짐
    언어의 경계가 없어진다는 건 한 언어(도메인)이 여러 도메인에서 섞여 쓰여짐

    잘 나눈 패키지로 문제 완화 : 수평적으로 나뉜 도메인을 수직적으로 나눈다.
        여전히 경계가 모호해질 가능성이 있다.
        ex> 사용자 관련 모듈, 프로젝트 관련 모듈을 수직으로 나누었지만 User Project가 M:N 관계일 때 DDD로 어떻게 적용할 수 있는가?
        실제 프로젝트에 참여한 멤버가 1:N. User는 그 자체. 프로젝트와 관련성을 나누기 위해 프로젝트를 분리 한다.(Bounded Context)
        User - Service  |  <---> Adapter, Member, Project

    분리에 따른 몇 가지 이점
        명시적인 (강제) 언어 경계(bounded)
        컨텍스트 별 독립적인 발전 (결합도가 높은 상태에서는 각 컨텍스트별 발전 시키기 어렵다)
        인터페이스에 기반한 컨텍스트 간 통신
        마이크로 서비스의 전형적인 장점과 동일하다

    Microservice의 특성
        * 서비스로서 컴포넌트화
            독립 배포 -> 서비스의 응집도(경계) 높아짐
            명시적 인터페이스 -> 공개 인터페이스(Open host service)
                DDD를 할 때 언어를 구성하는 중요한 요소이며 언어의 경계를 잘 나누는가가 DDD의 성공 가능성과 연결된다.
        * 비지니스 수행에 따른 구성
            cross functional teams | conway's law
            우리가 만드는 시스템은 조직의 모양을 따라간다. (ex> 직능조직(개발|디자인|기획)이면 시스템도 그렇게 흘러간다)
            마이크로서비스는 하나의 서비스를 만드는데 서비스를 만드는데 연관된 조직의 상태를 구성하게된다(비지니스 구조에 따른 구성이 이루진다??)
        프로젝트가 아닌 제품
        똑똑한 엔드포인트와 더미 (Dumb) 파이프
        * 분산한 데이터 관리
            수직으로 잘 나누어도 DB가 하나라면 개발자는 Join의 유혹에 빠질수 밖에 없다. (왜 User 테이블을 조인하지 않고 마이크로 서비스를 불러야 하는가! 고민에 빠진다)
            잘 분리할 경우 경계를 치는데 유리하다!
        * 진화하는 설계
            서비스별 독립적인 변경(교체/업그레이드)
            개별적 배포 능력이 중요할 수 있다. (큰 덩어리로 배포하는 부담을 어떻게 해야하는가!)
            Blue green? 손쉬운 변경?

        MS -> BC (MS를 구성하면서 얻는 이점)
        * 서비스로서 컴포넌트화
        * 비지니스 수행에 따른 구성
        * 분산한 데이터 관리
        * 진화하는 설계
         =>  언어의 경계를 찾아 Bounded Context를 구성하는데 도움을 줌
            DDD를 잘하기 위해서는 기술적 소양보다 도메인을 잘 이해하고 언어의 경계를 잘 구분지어 Bounded Context를 구성할 수 있는 능력

        MS로의 전환
            수직적으로 분할에 경험담(쿠팡)
                배포를 편하게 할 수 있다
                데이터를 가져올 때 성능문제가 있다()
                전환 과정중에 팀과의 관계에 문제가 있다(데이터를 전달 받는 입장이라 전달하는 측과 커뮤니케이션 비용이 크다)
                팀 단위로 관리하는 영역이 달라짐에 따라 API 협업에 드는 커뮤니케이션 비용이 많이 든다.
            배달의 민족
                각 조직에서 도메인 정리에 따른 API 서버를 나누려고 한다
                DB를 하나로 쓰고 있는데 이를 분리할지 고민

        정리
            MS를 하지 않더라도 도메인의 경계를 나누려는 노력이 있으면 도메인에 대해 더 잘 보일 것

# Event Sourcing + Aggregate

주문>결재>배송지변경>발송
데이터의 상태가 점진적으로 변한다
증분(변경본)이 누적되면 최종 상태

이벤트 소싱 Event Sourcing
    어플리케이션의 모든 상태 변화를 `순서에 따라` 이벤트로 보관
    리플리케이션도 비슷한 원리로 적용된다(변화본의 누적이 최종상태)

도메인 객체와 이벤트 소싱
    도메인 객체 조회
        저장한 인벤트로부터 도메인 객체 생성
    도메인 객체 변경
        모든 상태 변화에 대한 이벤트를 저장
    일관성의 기준인 애그리거트 단위로 이벤트 소스를 만든다

이벤트는 다른 시스템과의 연관관계를 나누어 줘 결합도를 낮춰준다.

이벤트의 발생 단위도 애그리거트(일관성의 단위)
    MS가 BC의 경계를 찾는데 도움이 되듯
    이벤트 소싱이 애그리거트의 경계를 찾는데 도움이 된다.

이벤트 구성
    구성
        애그리거트 타입
        애그리거트 식별자
        버전
        이벤트 타입
        이벤트 시간
        증분 내역
    이벤트 구분(uniqueness)
        애그리거트 타입/버전/식별자

애그리거트 조회
    리포지토리
     List<Event> events = eventStore.select(Order.class, orderId);
     for e in events
        order.handle(e)   // 여기서 상태를 변경

    애그리거트는 이벤트 반영
    * 즉, 이벤트를 모으면 최종 상태가 된다

애그리거트 변경
    애그리거트에서 이벤트 발생
        새로운 이벤트 생성 (ex> 주문 취소시 OrderCanceledEvent(id, version + 1) )
        본인의 상태를 변경하는게 아님
        생성된 이벤트가 Transaction이 commit되는 시점에 EventStore에 저장
            TransactionHandler  {
                commit() {
                    for e in events
                        eventStore.save(e)
                }
            }

이벤트 소싱과 유지보수
    왜 이벤트 소싱이 좋은가
        도메인 관점에서 봤을 때 유지보수가 좋다
        ex> 필드가 추가된 경우 이벤트 클래스를 버저닝 => DB 작업일정, 매핑 설정 변경이 없어진다.

이벤트 소싱 적용한 애그리거트
    임피던스 미스매치 없음
        DB와의 미스매칭을 해결할 수 있다
    애그리거트 간 참조는 ID
    비선점 잠금(낙관적 잠금)
        애그리거트는 버전을 가지기 때문에 서로 다른 데이터로 충돌나는 일을 막을 수 있다.

성능
    단일 애그리거트 조회 -> 스냅샷 (중간중간 데이터를 저장)
    복합 조회 -> CQRS

SQL(ORM) vs 이벤트 소싱
    변화되는 것
        메인 객체 로딩
            sql: select, orm: 매핑 -> 이벤트로부터 객체 도메인 생성 , 도메인 객체의 이벤트 핸들러를 이용해 상태 변경 반영

        메인 기능
            sql: 서비스 클래스, orm: 엔티티 클래스 -> 도메인 객체가 수행. 상태 변경을 위한 이벤트 생성

        상태변경 반영(데이터 변경)

장점
    DB에 의존적이지 않은 도메인 코드 구현
        테이블이나 ORM 기술의 제한/제약에서 벗어남
    기능 변경
        하위 호환 처리가 상대적으로 쉬엄
        이벤트로부터 완전히 새로운 도메인 객체의 생성도 가능
    버그 추적 용이
        이벤트를 차례대로 검사하면서 버그 원인 추적 가능
    객체 지향/DDD 와 좋은 궁합
        복잡한 도메메인을 객체지향적으로 구현하기에 좋음
    CQRS와 좋은 궁합
        조회 관련 코드를 도메인에서 분리
        성능 향상

단점
    익숙하지 않음
        sql 위주 개발 성향인 경우 적용 힘듬
    단순한 모델에는 적합하지 않음
        단순 모델에 적용하기엔 구현이 복잡
    도구 부족
        이벤트 소싱과  CQRS 프레임웍 부족
        AXON
    운영시 어려움
        이벤트 데이터만으로 최신 상태의 빠른 확인 어려움

# Lightning Talk

모놀리스
    각 도메인간 코드가 엮여있음
    다른 도메인 코드에 직접적 영향 발생
    빌드/테스트/배포 시간이 오래 걸림

모놀리스 -> MSA
    도메인 영역 설정
    조인 쿼리 제거
    공용으로 사용되는 데이터들을 각 도메인

MSA
    시간 단축
    도메인간 독립성
    도입 초기 장애 발생 -> 안정화 됨
    하나의 도메인이 성장하다 다시 찢어짐
    각 도메인간 관계가 복잡해지면서 다른 도메인간 이해가 힘듬
    커뮤니케이션 비용 발생

조회 성능
    정상 도메인: 2~3 도메인에 걸처있음
    JPA, Spring
    화면 조회는 속도 문제 없으나 대량 조회시 오래 걸림(다른 도메인 API 다량 호출)
        데이터가 많다
        외부 도메인의 데이터를 API로 불러옴
        잘못된 쿼리

    해결: 외부 데이터를 미리 모아둠(실시간성이 아니라서)

2.
모듈의 크기가 커지면서 테스트가 길어지는 문제
해결: CQS
    상태 변경은 반환 x
    조회는 상태 변경 x

서비스 상태를 변경하는지 검사하고 반환값을 만들어주는 것도 검사 해야 하기 때문에 테스트가 쉽게 깨짐

CQRS
메소드 분리에서 나아가 조회와 변경을 담당하는 시스템을 나누자
이 과정에서 DDD를 적용하니 가독성이 좋아지고
    쓰기 작업에 따른 모델에 임시성 필드를 두게 되어 굉장히 지저분
    모델을 두개로 나누는게 불필요하지 않는가 의문이었지만 가독성 등 이해하기 쉬워짐
쓰기모델/읽기모델의 일관성을 맞추는 시간 갭이 있다.
CQRS 적용하다보니 DDD 병행해야 효과가 있는것 같다.

# 3. SAGA

길게 실행되는 프로세스(Long Running Business Process)
주문 > 상품 보내기 > 배송 시작 알리기 > 구매확정 요청하기

특징
    여러 개의 작은 프로세스로 구성
    하위 프로세스가 순서대로 실행되는 건 아님
    여러 모듈/서비스가 엮임
    한 트랜젝션이 아님
    실패는 롤백 대신 보상으로 처리

SAGA
    여러 하위 트랜잭션 집합으로 구성된 LLT
        LLT : Long Lived Transaction
        단일 실행 단위
    SAGAS 논문
    각 하위 트랜잭션은 단독 트랜젝션
        하위 트랜잭션 단위로 일관성 보장
    각 하위 트랜잭션은 서로 연관
    하위 트랜잭션 실패시 보상 트랜잭션
        일부만 성공해도 끝나지 않음

SAGA -> 프로세스 매니저

프로세스 매니저
    여러 애그리거트/외부 시스템이 엮이는 긴 프로세스의 흐름 제어
        각 구성 요소 간의 메시지 라우팅이 주된 역할
    프로세스의 상태 보관
    비지니스 로직은 개별 구성 요소에서 처리

구현
    특정 이벤트에 saga/프로세스 매니저 시작
    수신한 이벤트에 따라 다음 기능 실행
        실패시 후속 보상 기능 실행
    전체 프로세스가 끝나면 saga/프로세스 매니저 종료

필요한 것
    SAGA 상태 영속화
        상태 유실되면 안됨
    이벤트 -> 해당 매니저 찾기 위해 효과적인 검색 수단 필요
    Saga 타임아웃

특징
    개별 애그리거트는 자기 자신의 도메인 로직에만 집중하면 됨
    한 비지니스 프로세스와 관련된 흐름 제어가 한 곳에 모임
        프로세스 변경 용이
    (주로) 비동기 이벤트 기반
    Saga 인스턴스 위한 기반 프레임워크 필요

정리
    어떤 프로세스가 진행되는 단계를 변경하는 곳에 여러 곳인 경우 응집도가 떨어지고 유지보수가 힘들다.
    각 단계별 진행을 위해 프로세스 매니저로 분리할 수 있다면
        애그리거트 별 도메인에 집중할 수 있다.