
변경 불가능(immutable) 클래스는 그 객체를 수정할 수 없는 클래스
ex> String, BigInteger, BigDecimal 클래스 등

변경 불가능한 클래스를 만들 때 다섯 규칙

1.객체 상태를 변경하는 메서드(수정자mutator 메서드) 제공하지 않는다
2.계승할 수 없다. class에 final 선언
3.모든 필드 final. 시스템이 강제하는 형태대로 프로그래머의 의도가 분명해진다. 새로운 생성 객체에 대한 참조가 동기화 없이 스래드 안전
4.모든 필드 private. 클라이언트가 필드를 참조하는 변경 가능 객체를 직접 수정하는 것을 막는다.
5.변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다. 클래스에 포함된 변경 가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야 한다. 클라이언트가 제공하는 객체로 초기화하면 안된다. 따라서 생성자나 접근자, readObject메서드(규칙 76)안에서는 방어적 복사본(defensive copy)을 만들어야한다(규칙 39)

함수형 접근법! (객체에 변경을 줄 경우 필드를 수정하는게 아닌 변경된 필드로 새로운 객체를 만들어 반환) 피연산자를 변경하는 대신 연산을 적용한 결과를 새롭게 만들어 반환

변경 불가능 객체는 단순하다.
스레드에 안전
자유롭게 공유 가능

변경 불가능 클래스는 자주 사용하는 객체를 캐시하여 객체가 거듭 생성되지 않도록 하는 정적 팩토리(규칙1)를 제공할 수 있다. ex> BigInteger, boxed primitive class

방어적 복사본을 만들 필요가 없다는 뜻(규칙 29)
애초에 복사본을 만들 필요가 없는데, 만들어봐야 객체와 영원히 같은 상태일 것이므로.


변경 불가능한 객체는 그 내부도 공유할 수 있다
BigInteger는 int변수와 int 배열이 있는데 새로운 negate 메서드는 BigInteger를 반환해도 내부적으로 int배열은 같은 배열을 참조

변경 불가능 객체는 다른 객체의 구성요소로도 훌륭
구성요소들의 상태가 변경되지 않는 객체는 복잡하더라도 쉽게 불변식을 준수.(ex> Map, Set 맵의 키나 집합의 원소로 활용하기 좋다. 한번 집어넣고나면 그 값이 변경되어 맵이나 집합의 불변성을 깰리 없다)

변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점
객체 생성 비용이 높을 가능성이 있다. 다양한 형태로 값이 변형되면 그 만큼의 객체 생성이 필요하다!!

이에 대응하는 방법은 두 가지
다단계 연산? 가운데 자주 요구되는 것을 기본 연산(primitive)으로 제공??
변경 가능한 package-private companion class 를 사용하는 접근법은 클라이언트가 변경 불가능한 클래스에 어떤 다단계 연산을 적용할지 정확하게 예측할 수 있을 때 쓸 수 있다. 그렇지 않다면 변경 가능한 public companion class를 제공하는 것이 최선
String 클래스. 이 클래스의 변경 가능 companion class 가 StringBuilder

한 가지 주의할 것은 직렬화 관련된 부분 변경 불가능 클래스가 Serializable 인터페이스를 구현하도록 했고, 해당 클래스에 변경 가능 객체를 참조하는 필드가 있다면 readObject 메서드나 readResolve 메서드를 반드시 제공해야 한다. 아니면 ObjectOutputStream.writeUnshared나 ObjectInputStream.readUnshared 메서드를 반드시 사용해야 한다. 
그렇지 않으면 시스템 공격자가 변경 불가능한 클래스로부터 변경 가능 객체를 만들 수 있게 된다. 규칙 76에서!

요약하자면 변경 가능한 클래스로 만들 타당한 이유가 없다면, 반드시 변경 불가능 클래스로 만들어야 한다.
변경 불가능한 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라.
특별한 이유가 없다면 모든 필드는 final!

객체 상태를 다른 초기치로 바꿔 재활용하는 “재 초기화” 메서드도 제공하지 마라. 코드 복잡성만 늘어나고 성능 향상에 도움되는 경우는 거의 없다. 

ex> TimerTask 클래스. 변경 가능 클래스지만 상태 변경 범위가 적다.


