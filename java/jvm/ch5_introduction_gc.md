# 가비지 컬렉션 입문

JVM의 GC

1. serial collector
2. parallel collector
3. concurrent collector, G1

## 개요

더 이상 사용되지 않는 객체 해제
사용되는지 여부를 판단하기 위해 사용되고 있는 객체를 카운팅하는 단순한 방법은 사용할 수 없다
어플리케이션 성능에 큰 영향을 미친다! GC가 장애로 이어질 수 있다.

GC의 성능은 미사용 객체 찾기, 가용 메모리 생성, 힙 압축과 같은 기본 동작
GC가 객체 참조를 추적하거나 메모리에 객체를 옮긴다면 어플리케이션 스레드가 사용하고 있지 않아야 한다. 
GC로 인해 어플리케이션 모든 스레드가 멈추는 때를 Stop The World라 부름

## 제너레이션간 GC들

모든 가비지 컬렉터는 힙을 별도의 제너레이션으로 나눠서 작업
영: 에덴, 서바이어1, 서바이어2
올드: tenured

영 GC, minor GC : 영 제너레이션에 대한 GC

영 제너레이션이 작은 경우 GC 시간은 짧을것. 반대인 경우 GC 시간이 길어지므로 STW가 길어지므로 트레이드 오프가 있다
영 GC 후 에덴의 모든 객체는 이동/폐기
영 GC를 통해 객체 참조들이 올드 제너레이션으로 이동되면서 올드 제너레레이션이 가득 찰 경우 올드 제너레이션을 GC = 풀 GC

Full GC는 보통 어플리케이션 스래드가 중지되면서 STW가 발생
어플리케이션 스레드가 실행되는 동안 미사용 객체를 찾는 CMS, G1이 있다. 대신 CPU를 더 많이 사용

## GC 알고리즘

* 시리얼 가비지 컬렉터

가장 단순
-XX:+UserSerialGC

* 처리율 컬렉터

GC 수행시 여러 스레드로 수행

-XX:+UseParallelGC
-XX:+UseParallelOldGC

* CMS 컬렉터

-XX:+UseConcMarkSweepGC
-XX:+

풀 GC에 생기는 긴 중지 현상을 없애도록 설계
마이너 GC 동안 어플리케이션 스레드를 전부 중지시키고 여러 스레드로 수행
영 제너레이션 수집하는데 처리율 컬렉터와 다른 알고리즘 사용 (-XX:+UseParNewGC)

CMS는 풀 GC 동안 어플리케이션 스레드를 중지시키지 않고 주기적으로 올드 제너레이션을 통해 살피고, 미사용 객체를 폐기하는 데 하나 이상의 백그라운드 스레드 사용. 저중지 컬렉터
CMS 백그라운드 스레드가 작업을 완료하는데 `충분한 CPU가 없거나 힙이 객체를 할당하는데 단편화가 너무 많이 된다면 시리얼 컬렉터의 동작`을 되돌린다 이 경우 STW
CPU 사용량이 트레이드 오프 


* G1 컬렉터 (Garbage First)

4G 이상의 큰 힙을 처리하도록 설계(그 이하는 일반적으로 CMS가 효율적)
힙을 여러 개의 영역으로 나누지만 여전히 제너레이션 기반 컬렉터.
CMS와의 차이는 올드 제너레이션을 나누어 처리한다.


명시적인 GC

System.gc() 로 명시적인 gc를 호출할 수 있지만 비효율적이다. `jcmd pid GC.run `으로도 가능
-XX:+DisableExplictGC 로 외부에서 호출되는 GC를 막을 수 있다. 


* 정리

CPU 한 개인 경우 시리얼 컬렉터, 추가 GC 스레드는 방해만 된다
G1 컬렉터도 어플리케이션 스레드가 동작하는 동안 잠재적으로 풀 GC를 회피하며 올드 제너레이션 수집
가용 CPU가 낮을 경우 CMS는 처리율 컬렉터보다 낮은 효율을 보인다

응답 시간이나 처리율을 측정할 때 처리율과 동시 병렬 컬렉터 중에서 선택할때는 가용 CPU 개수에 좌우
처리율 컬렉터는 보통 동시 병렬 컬렉터보다 평균 응답 시간이 더 빠르지만 동시 병렬 컬렉터는 흔히 90%,99%대 응답 시간이 더 빠를 것
처리율 컬렉터가 풀GC를 과도하게 수행하면 보통 동시 병렬 컬렉터의 평균 응답 시간이 더 빠른다

* CMS vs G1

CMS는 G1 보다 더 간단한 알고리즘
큰 힙을 사용할 때는 일을 분담할 수 있는 방식 덕분에 G1이 더 나을 것
G1은 올드 제너레이션을 여러 개의 영역으로 나누어 처리
CMS는 힙을 압축하지 않으나 G1은 부분적으로 힙 압축

## 기본 GC 튜닝 

* 힙 크기

스와핑은 OS에 의해 투명하게 제어되므로 JVM에서 스왑을 사용할 경우 성능 저하 발생하므로 힙 영역 설정을 가용 메모리 내에서 하는것이 좋다.
JVM이 GC가 너무 많이 일어난다는 걸 안다면 알아서 알맞은 GC의 수를 유지하거나 최대 크기가 될 때까지 힙을 늘림
힙 크기 설정에 있어 좋은 법칙은 풀 GC후 30%로 설정
명시적으로 최대 크기를 설정하더라도 힙의 크기는 자동으로 조정

* 제너레이션 크기 정하기

힙 크기가 결정되면 영/올드 에 얼마나 할당할지 결정해야 한다

-XX:NewRadio=N : 뉴/올드 비율
-XX:NewSize=N
-XX:MaxNewSize=N
-XmnN : NewSize MaxNewSize 동일 값을 설정하기 위한 약칭

초기 영 크기 = 초기 힙 크기 / (1 + NewRatio)

NewRatio 초기 값 2. 경의 기본 크기는 힙의 33%
Xmn으로 최대/최소 같은 경우 사용 

* 퍼머넌트/메타스페이스 크기 정하기

클래스 관련 데이터 덩어리
컴파일러와 JVM 런 타임에만 사용되며 클래스 메타 데이터라 부름
사용 하는 클래스에 비례하므로 크기를 미리 정하는건 좋지 않다
메타 스페이스는 필요한 만큼의 공강을 디폴트로 사용하므로 크기를 정할 필요가 없다
퍼머넌트 제너레이션이나 메타스페이스는 신규 클래스 정보로 가득 차 있지만 기존 클래스 메타 데이터는 해제될 수 있다.(여러번 배포된 경우)
jmap 인자로 -permstat, -clstat (java8)

* 병렬성 제어하기

JVM은 중지 시간 최소화를 위해 최대한 많은 CPU 자원을 사용하고자 한다
JVM이 한 머신 내 각 CPU당 스레드 한 개씩 8개 까지 실행 한다는의미

ParallelGCThreads = 8 + ((N - 8) * 5/8)     // N : CPU수
ex> 8개 CPU인 경우 4~6 스레드가 더 효율적

8개 이하 CPU가 달린 머신에서 GC는 머신상의 CPU 100% 소비할 것
JVM이 여러개 실행되고 있는 경우 GC를 위한 CPU 사용 경쟁이 치열할 수 있다. 

* 적응(Adaptive) 크기

적응 크기 조정은 JVM이 힙 내에서 영/올드 비율을 바꾸는 방법을 제어
JVM은 최적의 메모리 사용을 위해 힙과 제너레이션 크기를 자동 튜닝

* GC 도구

-verbose:gc
-XX:+PrintGC
-XX:+PrintGCDetails

-XX:+PrintGCTimeStamps : jvm 시작 후 상대 시간
-XX:+PrintGCDateStamps : 타임스탬프


-Xloggc:filename
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=N
-XX:GCLogFileSize=N

